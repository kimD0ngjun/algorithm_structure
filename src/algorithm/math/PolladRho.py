"""
소인수분해하려는 숫자 n = pq 에서 p와 q를 구하는 것이 목표

폴라드 로의 아이디어 시작
(1) mod 연산을 반복하다보면 언젠가는 자기 자신이 나온다
-> mod 연산이 가미된 수열로 생각할 것
ex) n = 91이라면
f(x) = (x² + 1) % 91
인덱스 i에 따른 함수 f(xᵢ), 초기값을 2라 두기

i ->  xᵢ = f(xᵢ₋₁)
0 ->  2
1 ->  5
2 -> 26
3 -> 41
4 -> 42
5 -> 37
6 -> 2 (순환 포인트 발생, 이 이후부터 계속 반복 구간)
...

mod 연산의 피제수 다항식은 경험칙적으로 '단순하면서 계산 빠름', '그러면서 충분히 섞임'을 만족해야 알고리즘 효율성
그래서 제곱 연산에 상수 가미로 선. 이를 지키지 않으면 주기가 너무 길어져서 탐색 실패 가능성이 높아짐
정리하자면 유사난수수열 발생기

(2) 근데 이게 봤을 때는 mod n에서의 수열 생성이지만
사실은 그 내부적으로 mod p에 대한 수열, mod q에 대한 수열도 같이 움직이는 셈
-> 중국인의 나머지 정리 : 어떤 수 x mod n (단, n=pq)는 동시에 x mod p와 x mod q로 구성된 정보와 같음

(3) (1)와 (2)에 따라 나온 후, mod p와 mod q의 순환 시점은 다르다
그래서 인덱스 i와 j에 대하여 xi = f(x(i-1)), xj = f(x(j-1))
xi ≡ xj mod p 를 만족하지만 xi !≡ xj mod q인 케이스가 존재
(참고로 정수론 합동도 이항 연산 가능)
그래서 xi - xj ≡ 0 mod p, but xi - xj !≡ 0 mod q 인 케이스 발생
다시 말하자면 xi - xj는 p의 배수지만, q의 배수가 아닌 상황 발생

(4) 최대공약수(gcd)를 활용해야 된다
파이썬에는 math 모듈, 자바에는 BigInteger 클래스에 gcd 관련 메소드가 존재
이를 사용하여

gcd(|xi - xj|, n)를 연산할 떄
p or q가 나오면 오케이
1이 나오면 아직 못 구했으니 계속 연산
n이 나오면 다른 f(x) 도입이 필요해진다

아까 (3)에서 xi - xj ≡ 0 mod p를 만족한다는 건, xi - xj = pk(k는 정수)를 의미
즉, gcd(pk, pq)를 연산할 수 있게됨을 의미. 즉, p의 배수이나 q의 배수가 아님을 활용해 gcd(|xi - xj|, n)에서 p를 연산할 수 있어짐
"""
import math


def pollard_rho(n):
    if n % 2 == 0:
        return 2 # 짝수는 당연히 2를 인수로 가지니

    # c의 변동을 통한 확률적 실패 대응
    for c in range(1, 10):
        xi = 2 # 수열의 초기화
        xj = 2 # 수열의 초기화
        d = 1 # 최대공약수 정답 변수
        f= lambda x: (x * x + c) % n # 유사난수발생기
    
        # 플로이드의 토끼와 거북이 알고리즘
        # x는 1칸, y는 2칸씩 뛰면서 수열 요소 탐색
        while d == 1:
            xi = f(xi)
            xj = f(f(xj))
    
            # 그에 따른 최대공약수 연산
            # 여기서 나온 값이 p 또는 q일지? 혹은 f의 수정이 필요할지?
            d = math.gcd(abs(xi - xj), n) # 자바는 BigInteger.valueOf(n).gcd(xi - xj)
    
        if d != n and d != 1:
            return d

    return None


if __name__ == '__main__':
    print(pollard_rho(91)) # 7
    print(pollard_rho(10403)) # 101
